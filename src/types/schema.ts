// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class LimitFarming extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LimitFarming entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LimitFarming must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LimitFarming", id.toString(), this);
    }
  }

  static load(id: string): LimitFarming | null {
    return changetype<LimitFarming | null>(store.get("LimitFarming", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get createdAtTimestamp(): BigInt {
    let value = this.get("createdAtTimestamp");
    return value!.toBigInt();
  }

  set createdAtTimestamp(value: BigInt) {
    this.set("createdAtTimestamp", Value.fromBigInt(value));
  }

  get rewardToken(): Bytes {
    let value = this.get("rewardToken");
    return value!.toBytes();
  }

  set rewardToken(value: Bytes) {
    this.set("rewardToken", Value.fromBytes(value));
  }

  get bonusRewardToken(): Bytes {
    let value = this.get("bonusRewardToken");
    return value!.toBytes();
  }

  set bonusRewardToken(value: Bytes) {
    this.set("bonusRewardToken", Value.fromBytes(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get startTime(): BigInt {
    let value = this.get("startTime");
    return value!.toBigInt();
  }

  set startTime(value: BigInt) {
    this.set("startTime", Value.fromBigInt(value));
  }

  get endTime(): BigInt {
    let value = this.get("endTime");
    return value!.toBigInt();
  }

  set endTime(value: BigInt) {
    this.set("endTime", Value.fromBigInt(value));
  }

  get reward(): BigInt {
    let value = this.get("reward");
    return value!.toBigInt();
  }

  set reward(value: BigInt) {
    this.set("reward", Value.fromBigInt(value));
  }

  get bonusReward(): BigInt {
    let value = this.get("bonusReward");
    return value!.toBigInt();
  }

  set bonusReward(value: BigInt) {
    this.set("bonusReward", Value.fromBigInt(value));
  }

  get isDetached(): boolean {
    let value = this.get("isDetached");
    return value!.toBoolean();
  }

  set isDetached(value: boolean) {
    this.set("isDetached", Value.fromBoolean(value));
  }

  get minRangeLength(): BigInt {
    let value = this.get("minRangeLength");
    return value!.toBigInt();
  }

  set minRangeLength(value: BigInt) {
    this.set("minRangeLength", Value.fromBigInt(value));
  }

  get tokenAmountForTier1(): BigInt {
    let value = this.get("tokenAmountForTier1");
    return value!.toBigInt();
  }

  set tokenAmountForTier1(value: BigInt) {
    this.set("tokenAmountForTier1", Value.fromBigInt(value));
  }

  get tokenAmountForTier2(): BigInt {
    let value = this.get("tokenAmountForTier2");
    return value!.toBigInt();
  }

  set tokenAmountForTier2(value: BigInt) {
    this.set("tokenAmountForTier2", Value.fromBigInt(value));
  }

  get tokenAmountForTier3(): BigInt {
    let value = this.get("tokenAmountForTier3");
    return value!.toBigInt();
  }

  set tokenAmountForTier3(value: BigInt) {
    this.set("tokenAmountForTier3", Value.fromBigInt(value));
  }

  get tier1Multiplier(): BigInt {
    let value = this.get("tier1Multiplier");
    return value!.toBigInt();
  }

  set tier1Multiplier(value: BigInt) {
    this.set("tier1Multiplier", Value.fromBigInt(value));
  }

  get tier2Multiplier(): BigInt {
    let value = this.get("tier2Multiplier");
    return value!.toBigInt();
  }

  set tier2Multiplier(value: BigInt) {
    this.set("tier2Multiplier", Value.fromBigInt(value));
  }

  get tier3Multiplier(): BigInt {
    let value = this.get("tier3Multiplier");
    return value!.toBigInt();
  }

  set tier3Multiplier(value: BigInt) {
    this.set("tier3Multiplier", Value.fromBigInt(value));
  }

  get multiplierToken(): Bytes {
    let value = this.get("multiplierToken");
    return value!.toBytes();
  }

  set multiplierToken(value: Bytes) {
    this.set("multiplierToken", Value.fromBytes(value));
  }

  get enterStartTime(): BigInt {
    let value = this.get("enterStartTime");
    return value!.toBigInt();
  }

  set enterStartTime(value: BigInt) {
    this.set("enterStartTime", Value.fromBigInt(value));
  }
}

export class EternalFarming extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save EternalFarming entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type EternalFarming must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("EternalFarming", id.toString(), this);
    }
  }

  static load(id: string): EternalFarming | null {
    return changetype<EternalFarming | null>(store.get("EternalFarming", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get rewardToken(): Bytes {
    let value = this.get("rewardToken");
    return value!.toBytes();
  }

  set rewardToken(value: Bytes) {
    this.set("rewardToken", Value.fromBytes(value));
  }

  get bonusRewardToken(): Bytes {
    let value = this.get("bonusRewardToken");
    return value!.toBytes();
  }

  set bonusRewardToken(value: Bytes) {
    this.set("bonusRewardToken", Value.fromBytes(value));
  }

  get virtualPool(): Bytes {
    let value = this.get("virtualPool");
    return value!.toBytes();
  }

  set virtualPool(value: Bytes) {
    this.set("virtualPool", Value.fromBytes(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get startTime(): BigInt {
    let value = this.get("startTime");
    return value!.toBigInt();
  }

  set startTime(value: BigInt) {
    this.set("startTime", Value.fromBigInt(value));
  }

  get endTime(): BigInt {
    let value = this.get("endTime");
    return value!.toBigInt();
  }

  set endTime(value: BigInt) {
    this.set("endTime", Value.fromBigInt(value));
  }

  get reward(): BigInt {
    let value = this.get("reward");
    return value!.toBigInt();
  }

  set reward(value: BigInt) {
    this.set("reward", Value.fromBigInt(value));
  }

  get bonusReward(): BigInt {
    let value = this.get("bonusReward");
    return value!.toBigInt();
  }

  set bonusReward(value: BigInt) {
    this.set("bonusReward", Value.fromBigInt(value));
  }

  get rewardRate(): BigInt {
    let value = this.get("rewardRate");
    return value!.toBigInt();
  }

  set rewardRate(value: BigInt) {
    this.set("rewardRate", Value.fromBigInt(value));
  }

  get bonusRewardRate(): BigInt {
    let value = this.get("bonusRewardRate");
    return value!.toBigInt();
  }

  set bonusRewardRate(value: BigInt) {
    this.set("bonusRewardRate", Value.fromBigInt(value));
  }

  get isDetached(): boolean {
    let value = this.get("isDetached");
    return value!.toBoolean();
  }

  set isDetached(value: boolean) {
    this.set("isDetached", Value.fromBoolean(value));
  }

  get minRangeLength(): BigInt {
    let value = this.get("minRangeLength");
    return value!.toBigInt();
  }

  set minRangeLength(value: BigInt) {
    this.set("minRangeLength", Value.fromBigInt(value));
  }

  get tokenAmountForTier1(): BigInt {
    let value = this.get("tokenAmountForTier1");
    return value!.toBigInt();
  }

  set tokenAmountForTier1(value: BigInt) {
    this.set("tokenAmountForTier1", Value.fromBigInt(value));
  }

  get tokenAmountForTier2(): BigInt {
    let value = this.get("tokenAmountForTier2");
    return value!.toBigInt();
  }

  set tokenAmountForTier2(value: BigInt) {
    this.set("tokenAmountForTier2", Value.fromBigInt(value));
  }

  get tokenAmountForTier3(): BigInt {
    let value = this.get("tokenAmountForTier3");
    return value!.toBigInt();
  }

  set tokenAmountForTier3(value: BigInt) {
    this.set("tokenAmountForTier3", Value.fromBigInt(value));
  }

  get tier1Multiplier(): BigInt {
    let value = this.get("tier1Multiplier");
    return value!.toBigInt();
  }

  set tier1Multiplier(value: BigInt) {
    this.set("tier1Multiplier", Value.fromBigInt(value));
  }

  get tier2Multiplier(): BigInt {
    let value = this.get("tier2Multiplier");
    return value!.toBigInt();
  }

  set tier2Multiplier(value: BigInt) {
    this.set("tier2Multiplier", Value.fromBigInt(value));
  }

  get tier3Multiplier(): BigInt {
    let value = this.get("tier3Multiplier");
    return value!.toBigInt();
  }

  set tier3Multiplier(value: BigInt) {
    this.set("tier3Multiplier", Value.fromBigInt(value));
  }

  get multiplierToken(): Bytes {
    let value = this.get("multiplierToken");
    return value!.toBytes();
  }

  set multiplierToken(value: Bytes) {
    this.set("multiplierToken", Value.fromBytes(value));
  }
}

export class Deposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Deposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Deposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Deposit", id.toString(), this);
    }
  }

  static load(id: string): Deposit | null {
    return changetype<Deposit | null>(store.get("Deposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get L2tokenId(): BigInt {
    let value = this.get("L2tokenId");
    return value!.toBigInt();
  }

  set L2tokenId(value: BigInt) {
    this.set("L2tokenId", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get onFarmingCenter(): boolean {
    let value = this.get("onFarmingCenter");
    return value!.toBoolean();
  }

  set onFarmingCenter(value: boolean) {
    this.set("onFarmingCenter", Value.fromBoolean(value));
  }

  get pool(): Bytes {
    let value = this.get("pool");
    return value!.toBytes();
  }

  set pool(value: Bytes) {
    this.set("pool", Value.fromBytes(value));
  }

  get limitFarming(): Bytes | null {
    let value = this.get("limitFarming");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set limitFarming(value: Bytes | null) {
    if (!value) {
      this.unset("limitFarming");
    } else {
      this.set("limitFarming", Value.fromBytes(<Bytes>value));
    }
  }

  get eternalFarming(): Bytes | null {
    let value = this.get("eternalFarming");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set eternalFarming(value: Bytes | null) {
    if (!value) {
      this.unset("eternalFarming");
    } else {
      this.set("eternalFarming", Value.fromBytes(<Bytes>value));
    }
  }

  get enteredInEternalFarming(): BigInt | null {
    let value = this.get("enteredInEternalFarming");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set enteredInEternalFarming(value: BigInt | null) {
    if (!value) {
      this.unset("enteredInEternalFarming");
    } else {
      this.set("enteredInEternalFarming", Value.fromBigInt(<BigInt>value));
    }
  }

  get liquidity(): BigInt {
    let value = this.get("liquidity");
    return value!.toBigInt();
  }

  set liquidity(value: BigInt) {
    this.set("liquidity", Value.fromBigInt(value));
  }

  get rangeLength(): BigInt {
    let value = this.get("rangeLength");
    return value!.toBigInt();
  }

  set rangeLength(value: BigInt) {
    this.set("rangeLength", Value.fromBigInt(value));
  }

  get tokensLockedLimit(): BigInt {
    let value = this.get("tokensLockedLimit");
    return value!.toBigInt();
  }

  set tokensLockedLimit(value: BigInt) {
    this.set("tokensLockedLimit", Value.fromBigInt(value));
  }

  get tokensLockedEternal(): BigInt {
    let value = this.get("tokensLockedEternal");
    return value!.toBigInt();
  }

  set tokensLockedEternal(value: BigInt) {
    this.set("tokensLockedEternal", Value.fromBigInt(value));
  }

  get tierLimit(): BigInt {
    let value = this.get("tierLimit");
    return value!.toBigInt();
  }

  set tierLimit(value: BigInt) {
    this.set("tierLimit", Value.fromBigInt(value));
  }

  get tierEternal(): BigInt {
    let value = this.get("tierEternal");
    return value!.toBigInt();
  }

  set tierEternal(value: BigInt) {
    this.set("tierEternal", Value.fromBigInt(value));
  }
}

export class Reward extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Reward entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Reward must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Reward", id.toString(), this);
    }
  }

  static load(id: string): Reward | null {
    return changetype<Reward | null>(store.get("Reward", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get rewardAddress(): Bytes {
    let value = this.get("rewardAddress");
    return value!.toBytes();
  }

  set rewardAddress(value: Bytes) {
    this.set("rewardAddress", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }
}

export class Token extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Token entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Token must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Token", id.toString(), this);
    }
  }

  static load(id: string): Token | null {
    return changetype<Token | null>(store.get("Token", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    return value!.toString();
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get decimals(): BigInt {
    let value = this.get("decimals");
    return value!.toBigInt();
  }

  set decimals(value: BigInt) {
    this.set("decimals", Value.fromBigInt(value));
  }
}
